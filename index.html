<!DOCTYPE html>
<html>
  <head>
    <title>Asseambly Carving</title>
    <link
      rel="icon"
      href="https://assemblyscript.org/favicon.ico"
      type="image/x-icon"
    />
    <meta name="viewport" content="user-scalable=0" />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        color: #111;
        background: #fff;
        font-family: sans-serif;
      }
      body {
        border-top: 2px solid #bc18d4;
      }
      h1 {
        padding: 18px 20px 20px;
        font-size: 12pt;
        margin: 0;
      }
      a {
        color: #111;
        text-decoration: none;
      }
      a:hover {
        color: #bc18d4;
        text-decoration: underline;
      }
      canvas {
        background: #100707;
        cursor: cell;
        user-select: none;
        outline: 1px solid red;
        image-rendering: optimizeSpeed;
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: -o-crisp-edges;
        image-rendering: optimize-contrast;
        image-rendering: crisp-edges;
        image-rendering: pixelated;
        -ms-interpolation-mode: nearest-neighbor;
      }
    </style>
  </head>
  <body>
    <canvas id="image-loader"></canvas>
    <canvas id="canvas"></canvas>
    <script>
      'use strict';

      const IMAGE_URL = 'pic.png';

      function setupCanvas(width, height) {
        let cnv = document.getElementById('canvas');
        let ctx = cnv.getContext('2d');
        cnv.width = width;
        cnv.height = height;
        ctx.imageSmoothingEnabled = false;
      }

      async function loadModule(memory) {
        // Fetch and instantiate the module
        return await fetch('build/untouched.wasm')
          .then(response => response.arrayBuffer())
          .then(buffer =>
            WebAssembly.instantiate(buffer, {
              env: {
                memory,
                abort: (...args) => console.log(...args),
                trace: (...args) => console.log('trace:', ...args)
              },
              config: {},
              Math
            })
          )
          .catch(err => {
            alert(
              'Failed to load WASM: ' + err.message + ' (ad blocker, maybe?)'
            );
            console.log(err.stack);
          });
      }

      (async function run() {
        await testInvertingImageWithWasm(IMAGE_URL);
        // await testDrawingPixelDataToCanvasWasm(0xff0000ff, 100, 100);
        // await testImageDataLocally(0xffff0000, 100, 100);
      })();

      // 1. Loads the image from the given URL,
      // 2. gets the pixel data from the image
      // 3. load the pixel data into the WebAssembly.Memory
      // 4. call the wasm `invert` method which inverts the data in the memory
      // 5. draw the memory into a canvas
      async function testInvertingImageWithWasm(imageUrl) {
        let loadedImageData = await loadImage(IMAGE_URL);
        let { width, height } = loadedImageData;
        let memory = new WebAssembly.Memory({
          // 4 bytes per pixel, width*height pixels, 2^16 bytes per Wasm memory page
          initial: Math.ceil((width * height * 4) / (1 << 16))
        });
        let module = await loadModule(memory);
        putImageDataIntoMemory(loadedImageData.data, memory);
        module.instance.exports.invert(width * height);
        let imageData = getImageDataFromWasmMemory(
          module.instance.exports.memory,
          width,
          height
        );
        drawImageDataIntoCanvas(imageData, width, height);
      }

      function drawImageDataIntoCanvas(imageData, width, height) {
        let canvas = document.getElementById('canvas');
        canvas.width = width;
        canvas.height = height;
        let ctx = canvas.getContext('2d');
        ctx.putImageData(imageData, 0, 0);
      }

      function getImageDataFromWasmMemory(memory, width, height) {
        return new ImageData(
          new Uint8ClampedArray(memory.buffer, 0, width * height * 4),
          width,
          height
        );
      }

      function createWasmMemory(bytes) {
        return new WebAssembly.Memory({
          initial: Math.ceil(bytes / (1 << 16))
        });
      }

      // pixelColor should be little-endian 32-bit integer, ABGR
      async function testDrawingPixelDataToCanvasWasm(
        pixelColor = 0xff00cccc,
        width = 100,
        height = 100
      ) {
        let module = await loadModule(createWasmMemory(width * height * 4));
        module.instance.exports.writeImageData(width * height, pixelColor);
        drawImageDataIntoCanvas(
          getImageDataFromWasmMemory(
            module.instance.exports.memory,
            width,
            height
          ),
          width,
          height
        );
      }

      function testImageDataLocally(
        pixelColor = 0xff00ff00,
        width = 100,
        height = 100
      ) {
        drawImageDataIntoCanvas(
          generateImageData(pixelColor, width, height),
          width,
          height
        );
      }

      function generateImageData(pixelColor, width, height) {
        let imageData = new ImageData(width, height);
        let dataUint32 = new Uint32Array(imageData.data.buffer);

        for (let i = 0; i < dataUint32.length; i++) {
          dataUint32[i] = pixelColor;
        }

        return imageData;
      }

      function viewMemory(memory) {
        let view = new Uint32Array(memory.buffer);
        for (let i = 0; i < 10; i++) {
          console.log(`memory@${i}: ${view[i]}`);
        }
      }

      function putImageDataIntoMemory(imageData, memory) {
        let mem = new Uint8Array(memory.buffer);
        mem.set(imageData.data);
      }

      function drawImageFromMemory(width, height, memory) {
        let size = width * height;
        let mem = new Uint32Array(memory.buffer);
        let ctx = document.getElementById('canvas').getContext('2d');
        let imageData = ctx.createImageData(width, height);
        let argb = new Uint32Array(imageData.data.buffer);
        argb.set(mem.subarray(0, size));
        ctx.putImageData(imageData, 0, 0);
      }

      async function loadImage(url) {
        let image = document.createElement('img');
        image.setAttribute('src', url);
        image.style = 'display: none';
        let result = new Promise((resolve, reject) => {
          image.onload = e => {
            console.log('done w image', e);
            resolve(image);
          };
          image.onerror = e => reject(e);
        })
          .then(image => {
            let { width, height } = image;
            let loaderCanvas = document.getElementById('image-loader');
            let ctx = loaderCanvas.getContext('2d');
            loaderCanvas.width = width;
            loaderCanvas.height = height;
            ctx.drawImage(image, 0, 0, width, height);
            return {
              width,
              height,
              data: ctx.getImageData(0, 0, width, height)
            };
          })
          .finally(() => {
            document.body.removeChild(image);
          });
        document.body.appendChild(image);
        return result;
      }
    </script>
  </body>
</html>
