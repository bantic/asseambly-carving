{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","assembly/index.ts"],"names":[],"mappings":"0MEUQ,mDACE,IACC,IAIK,IACC,AAAc,AAHd,EAAQ,GAAS,KAGjB,KACF,EAAc,GAAe,KACpC,4DAIe,EAAI,KACZ,EAAK,GAAG,KADU,sBAMV,EAAI,KAGZ,AAAY,AADR,EAAa,AADR,EAAK,SAEd,QACA,EAAQ,KAJU,gBAqEzB,GAAsB,oDA2BtB,GAAoB,oDAwBpB","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Value is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Value is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","// The entry file of your WebAssembly module.\nconst fullAlpha = 0xff000000;\n\nvar width: u32;\nvar height: u32;\nconst bytesPerPixel: u32 = 4; // r, g, b and a\nvar pixelOffset: u32;\nvar energyOffset: u32;\nvar costOffset: u32;\nexport function init(w: u32, h: u32): void {\n  trace('1 init');\n  width = w;\n  height = h;\n\n  let byteSize = width * height * bytesPerPixel;\n\n  pixelOffset = 0;\n  energyOffset = pixelOffset + byteSize;\n  costOffset = pixelOffset + energyOffset + byteSize;\n  trace('3 init');\n}\n\nexport function writeImageData(size: u32, color: u32): void {\n  for (let i: u32 = 0; i < size; i++) {\n    store<u32>(i << 2, color);\n  }\n}\n\nexport function invert(size: u32): void {\n  for (let i: u32 = 0; i < size; i++) {\n    let val = load<u32>(i << 2);\n    let inverted = 0xffffffff - val;\n    inverted = fullAlpha | inverted; // ensure 0xff full alpha\n    store<u32>(i << 2, inverted);\n  }\n}\n\n// @inline\nfunction pixelIdx(x: u32, y: u32, width: u32): u32 {\n  return (y * width + x) << 2;\n}\n\nfunction outPixelIdx(x: u32, y: u32, width: u32, offset: u32): u32 {\n  return (offset + y * width + x) << 2;\n}\n\n// @inline\nfunction pixelVal(x: u32, y: u32, width: u32): u32 {\n  return load<u32>(pixelIdx(x, y, width));\n}\n\n// @inline\nfunction _pixelIdx(x: u32, y: u32): u32 {\n  return pixelOffset + (y * width + x) * bytesPerPixel;\n}\n\nfunction getPixel(x: u32, y: u32): u32 {\n  return load<u32>(_pixelIdx(x, y));\n}\n\nfunction setPixel(x: u32, y: u32, value: u32): void {\n  store<u32>(_pixelIdx(x, y), value);\n}\n\nfunction _energyIdx(x: u32, y: u32): u32 {\n  return energyOffset + (y * width + x) * bytesPerPixel;\n}\n\nfunction setEnergy(x: u32, y: u32, value: u32): void {\n  store<u32>(_energyIdx(x, y), value);\n}\n\nfunction getEnergy(x: u32, y: u32): u32 {\n  return load<u32>(_energyIdx(x, y));\n}\n\nfunction _costIdx(x: u32, y: u32): u32 {\n  return costOffset + (y * width + x) * bytesPerPixel;\n}\n\nfunction setCost(x: u32, y: u32, value: u32): void {\n  store<u32>(_costIdx(x, y), value);\n}\n\nfunction getCost(x: u32, y: u32): u32 {\n  return load<u32>(_costIdx(x, y));\n}\n\nfunction energyDiff(a: u32, b: u32): u32 {\n  // pixel data is little-endian: ABGR\n  let diffR = (a & 0xff) - (b & 0xff); // rightmost byte\n  let diffG = ((a >> 8) & 0xff) - ((b >> 8) & 0xff); // 2nd-rightmost byte\n  let diffB = ((a >> 16) & 0xff) - ((b >> 16) & 0xff); // 3rd-rightmost byte\n\n  return diffR * diffR + diffG * diffG + diffB * diffB;\n}\n\nexport function calculateEnergyMap(): void {\n  trace('calculateEnergyMap', 0);\n  // assert(width !== 0, 'Cannot calculate energy map before calling init');\n  // assert(height !== 0, 'Cannot calculate energy map before calling init');\n\n  // for (let x: u32 = 0; x < width; x++) {\n  //   for (let y: u32 = 0; y < height; y++) {\n  //     let leftX = x === 0 ? width - 1 : x - 1;\n  //     let rightX = x === width - 1 ? 0 : x + 1;\n  //     let upY = y === 0 ? height - 1 : y - 1;\n  //     let downY = y === height - 1 ? 0 : y + 1;\n\n  //     let xEnergy = energyDiff(getPixel(leftX, y), getPixel(rightX, y));\n  //     let yEnergy = energyDiff(getPixel(x, upY), getPixel(x, downY));\n  //     let energy = xEnergy + yEnergy;\n  //     trace('Set energy for x,y =', 3, x, y, energy);\n  //     setEnergy(x, y, energy);\n  //   }\n  // }\n}\n\n/**\n * This step is implemented with dynamic programming. The value of each pixel\n * is equal to its corresponding value in the energy map added to the minimum\n * new neighbor energy introduced by removing one of its three top neighbors\n * (top-left, top-center, and top-right)\n */\nexport function calculateCostMap(): void {\n  trace('calculateCostMap', 0);\n  // assert(width !== 0, 'Cannot calculate energy map before calling init');\n  // assert(height !== 0, 'Cannot calculate energy map before calling init');\n\n  // for (let x: u32 = 0; x < width; x++) {\n  //   for (let y: u32 = 0; y < height; y++) {\n  //     let energy = getEnergy(x, y);\n  //     if (y === 0) {\n  //       setCost(x, y, energy);\n  //     } else {\n  //       let minPrevEnergy = getEnergy(x, y - 1);\n  //       if (x > 0) {\n  //         minPrevEnergy = min(minPrevEnergy, getEnergy(x - 1, y - 1));\n  //       }\n  //       if (x < width - 1) {\n  //         minPrevEnergy = min(minPrevEnergy, getEnergy(x + 1, y - 1));\n  //       }\n  //       setCost(x, y, energy + minPrevEnergy);\n  //     }\n  //   }\n  // }\n}\n\nexport function return1(): void {\n  trace('return1');\n  // calculateEnergyMap();\n  // calculateCostMap();\n  // let seam = Array.create<u32>(height);\n  // for (let y: u32 = height - 1; y >= 0; y--) {\n  //   let minX: u32 = 0;\n  //   let minCost: u32 = 0;\n  //   for (let x: u32 = 0; x < width; x++) {\n  //     let cost = getCost(x, y);\n  //     if (minCost === 0) {\n  //       minCost = cost;\n  //     }\n  //     if (cost < minCost) {\n  //       minCost = cost;\n  //       minX = x;\n  //     }\n  //   }\n  //   seam[y] = minX;\n  //   trace('Min cost, min X for Y', 3, minCost, minX, y);\n  // }\n  // return seam;\n}\n"]}